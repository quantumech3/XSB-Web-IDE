Description
-------------------------
Emscripten has a many tools that allow interface to be written for C, but Emscripten also has an interface for porting C++ code called 'Embind'. 'Embind' allows you to port methods, classes, structures and even variables to an extent so that they can be used in JS. 'Embind' also allows you to interact with JS in C++!

How to use Embind BASICS
-------------------------
1. Bind your symbols using the <emscripten/bind.h> and EMSCRIPTEN_BINDINGS macro (See example for how to use the macro)
2. Compile source code with the `--bind` option
3. Access exposed symbols in JS using `Module.symbol`. Even though the symbols are in global scope, its safer to access symbols though the `Module` object defined by Emscripten.

Function Example
-------------------------
#include <emscripten/bind.h>

// Bring Emscripten namespace into scope for the sake of readability
using namespace emscripten;

// Method being exported to JS
float lerp(float a, float b, float t)
{
	return (1 - t) * a + t * b;
}

// Embind Block that registers the 'lerp()' method under the group 'Module'
EMSCRIPTEN_BINDINGS(Module) {
	function("lerp", &lerp);
}

Class example
-------------------------
#include <emscripten/bind.h>

// Bring Emscripten namespace into scope for the sake of readability
using namespace emscripten;

class Vertex
{
	double x;	
	double y;

public:

	Vertex(int x, int y): x(x), y(y)
	{}

	double getX() const { return this->x; } // <--- Getters for 'properties' must be 'const' methods. 
	void setX(double x) { this->x = x; }	// 		Notice how this is different from returning a const
	double getY() const { return this->y; }	// 		value. 'const' keyword declared this way tells the compiler
											// 		to throw an error if any attributes get changed inside of the method

	void setY(double y) { this->y = y; }

	void invert()
	{
		x = -x;
		y = -y;
	}

	static Vertex VertexFactory(double x, double y)
	{
		return Vertex(x, y);
	}
};


EMSCRIPTEN_BINDINGS(Module) {
	class_<Vertex>("Vertex")
		.constructor<double, double>()	// <--- Register contructor that takes 2 doubles as arguments. You can also do '.constructor(&func)' to register an external function as a constructor
		.property("x", &Vertex::getX, &Vertex::setX) // <-- Register a 'property'. 'Properties' are JS variables
		.property("y", &Vertex::getY, &Vertex::setY) // 	that call getters and setters when a variable is accessed.
													 // 	So when 'Vertex.x = 4' is called, setX() will be called to
													 // 	mutate 'x' 
		.function("invert", &Vertex::invert) // <-- Register an instance function (ie. a function that is called per instance)
		.class_function("VertexFactory", &Vertex::VertexFactory); // <-- Register a static function 
																  //     (ie. a function that can be directly called 
																  //	  from the class)
}

Example of class that inherits another class
--------------------------
#include <emscripten/bind.h>
#include <iostream>

using namespace emscripten;

class BaseClass
{
	public:

	BaseClass(){}

	void Hello()
	{

	}

	void Goodbye()
	{
		std::cout << "Goodbye" << std::endl;
	}
};

class SubClass : public BaseClass
{
	public:
	void Hello()
	{
		std::cout << "Hello" << std::endl;
	}

	int Add(int a, int b)
	{
		return a + b;
	}
};

EMSCRIPTEN_BINDINGS(Module)
{
	class_<BaseClass>("BaseClass") // Register base class and all its attributes
		.constructor<>()
		.function("Hello", &BaseClass::Hello)
		.function("Goodbye", &BaseClass::Goodbye);

//Notice the extra parameter passed to 'class_' template 
//						|
//						V
	class_<SubClass, base<BaseClass>>("SubClass") // SubClass will also have all the attributes of baseclass
		.constructor<>()
		.function("Hello", &SubClass::Hello)
		.function("Add", &SubClass::Add);
}

'value_array' Struct example
-------------------------
#include <emscripten/bind.h>

// Bring Emscripten namespace into scope for the sake of readability
using namespace emscripten;

// Struct that is treated in JS like an array. 'returnX(Point(1,5))' => 'Module.returnX([1,5])'
// This struct is treated like an array because it is being registered as a 'value_array'
struct Point
{
	int x;
	int y;
};

int returnX(Point pt)
{
	return pt.x;
}

EMSCRIPTEN_BINDINGS(Module)
{
	value_array<Point>("Point") // <-- Register 'value_array' called 'Point'. 'value_arrays'
								//	   are structs that are treated like arrays in JS.
		.element(&Point::x)		// <-- Set 'Point::X' to be the first element
		.element(&Point::y);    // <-- Set 'Point::Y' to be the second element

	function("returnX", &returnX); // <-- Register method to return the X value of 'Point' struct
}

'value_object' struct example
-------------------------
#include <emscripten/bind.h>

// Bring Emscripten namespace into scope for the sake of readability
using namespace emscripten;

// Struct that is treated like a class in JS such that 'Point::x' => 'instance.x'
// is called a 'value_object'
// 'value_objects' are treated as dictionaries in JS. You can even define new structs this way
//
// For example: 'let x = {x: 44, y: 66}' => 'Point pt = Point {44, 66}'
struct Point
{
	int x;
	int y;
};

Point PointFactory(int x, int y)
{
	return Point {x, y};
}

int getX(Point pt)
{
	return pt.x;
}

EMSCRIPTEN_BINDINGS(Module)
{
	value_object<Point>("Point")   // <-- Register 'Point' as a value object such that
		.field("x", &Point::x)	   // 	  'Point::x' => 'instance.x' &
		.field("y", &Point::y);    //     'Point::y' => 'instance.y'

	function("PointFactory", &PointFactory); // <-- Register method to return a new 'Point' struct instance

	function("getX", &getX);
}



Register methods that return pointers
--------------------------------------
#include <emscripten/bind.h>
#include <iostream>

// Bring Emscripten namespace into scope for the sake of readability
using namespace emscripten;

// Raw pointers are only able to point to classes.
// Anything else will throw an 'UnboundType' error
class C
{
	public:
	void HelloWorld()
	{
		std::cout << "Hello world" << std::endl;
	}
};

// Factory method that returns a new instance of the C class
// This method is exported to JS
C* CFactory(){ return new C(); }

EMSCRIPTEN_BINDINGS(Module)
{
	class_<C>("C").
		function("HelloWorld", &C::HelloWorld);

	function("CFactory", &CFactory, allow_raw_pointers()); // Notice 'allow_raw_pointers()'
														   // You need to explicitly declare when you want
														   // to use pointers
}

Overload virtual methods in JS
-------------------------
I feel that the documentation is sufficient enough
https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#abstract-methods

Register Enums
------------------
#include <emscripten/bind.h>
#include <iostream>

using namespace emscripten;

// Enum being registered to JS
enum Piece
{
	X,
	O,
	NaN
};

// Register JS enum
EMSCRIPTEN_BINDINGS(Module)
{
	enum_<Piece>("Piece")
		.value("X", Piece::X)
		.value("O", Piece::O);
}

Register Constants
------------------
#include <emscripten/bind.h>
#include <iostream>

using namespace emscripten;

// Define constant being exposed
const double PI = 3.141592653589793238463;

// Expose PI constant to JS
EMSCRIPTEN_BINDINGS(Module)
{
	constant("PI", PI);
}

Return pointer to a variable
-----------------------------
#include <emscripten/bind.h>
#include <iostream>

using namespace emscripten;

// Data being sent to JS via TypedArray
// Has length of 309
char* data = "sadiofhsdoithqrp;lstgnpoulgdfjna;gunhdfso;gljkpuahsptr hnweqopmftopirsmgrstm,rwheiopt,w	qgtiop	rno	enbrgorlgnvolfsd;cgbunpqerbgnjla;sdfbgoufld;grqeibtgr pvmoqmwprul;tlmv 	qweuumpvthwuioetqvlqmw;etvumqhtvuiormthvqeuoitv,uhreamoithgl;hlajghknfihgrel;agheirgdoga;lhe;rhgoueobmopiamvrotmq3498vtm4p35ty;vmqa;tvyn ";

// Method being registered to JS
// Returns handle to 'data'
//
// 'val' is defined by Emscripten and is used to return JS objects from C++
val getAlotOfData()
{
	// In this particular instance,
	// this method will return an Int8Array with with a handle to the 'data' variable's memory
	// This means that you are able to edit the variable in JS because its essentially passing a
	// pointer
	// 
	// But Emscripten will return the JS TypedArray datatype makes the most sense
	return val(typed_memory_view(309, data));
}

// Register 'getAlotOfData()'
EMSCRIPTEN_BINDINGS(Module)
{
	function("getAlotOfData", &getAlotOfData);
}

Manipulate global JS variables in C++ with 'val' type
-------------------------------------
C++:
#include <emscripten/bind.h>
#include <iostream>

using namespace emscripten;

void changeGlobalVar()
{
	// Get 'globalVar' variable from JS
	// The 'val' datatype allows you to get JS objects, set their attributes,
	// call their methods and much more as specified here
	// https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#using-val-to-transliterate-javascript-to-c
	val globalJSVar = val::global("globalVar");

	// Set globalVar.name to "Scott Burgert"
	globalJSVar.set("name", val("Scott Burgert"));

	// Set globalVar.ID to 12345
	globalJSVar.set("ID", val(12345));

	// Call 'globalVar.display()'
	// display() does not need any arguments, however if it did, you would just pass
	// arguments into the parameters after the method name parameter
    	//Arg:	returnType | funcName | args
	globalJSVar.call<void>("display");

	
}

EMSCRIPTEN_BINDINGS(Module)
{
	function("changeGlobalVar", &changeGlobalVar);
}

JS:
var globalVar = 
{
	name: "NOT SET",
	ID: 0,
	display: function()
	{
		console.log("Name: " + this.name)
		console.log("ID: " + this.ID)
	}
}

Module.onRuntimeInitialized = function()
{
	Module.changeGlobalVar()
}

Register C++ vectors and maps as datatypes in JS
---------------------------------------------
C++:
#include <emscripten/bind.h>
#include <vector>

using namespace emscripten;

// Method that gets called by JS to return a vector
std::vector<int> returnVector()
{
	// Initialize vector with values {4, 5, 6}
	std::vector<int> vec;
	vec.push_back(4);
	vec.push_back(5);
	vec.push_back(6);

	return vec;
}

// Register vector and factory method
EMSCRIPTEN_BINDINGS(Module)
{
	register_vector<int>("vector<int>"); // <-- Register vector<int> as a JS datatype
										 	 // You are able to do the same thing with maps..
	function("returnVector", &returnVector); // as well. Just swap out 'register_vector' for 'register_map'
}

JS:
Module.onRuntimeInitialized = function()
{
	// Get C++ vector
	// Vector gets returned as an object with all the same attributes..
	// ..as a C++ vector.
	let vector = Module.returnVector();

	// Print all values of the vector (4, 5, 6)
	for(let i = 0; i < vector.size(); i++)
	{
		console.log(vector.get(i));
	}
}

Please note that
-------------------------
* Embind is **only** supported in C++. **C code is not compatible with Embind**
* If you use the `.property` statement for binding an attribute to a class, the **getter methods must be declared const. This is different from just making it return a const type. Here is how to make a method const https://www.geeksforgeeks.org/const-member-functions-c/**
* Emscripten will **not** automatically destruct C++ class instances or pointers. You must delete instances yourself
* You can delete C++ class instances by invoking `instance.delete()`
* You can register methods that return and use raw pointers, but you must register them with 'allow_raw_pointers()' and they may only reference classes
* 

Sources
-------------------------
https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html
https://emscripten.org/docs/api_reference/bind.h.html#_CPPv2NK6class_14class_functionEv
https://www.geeksforgeeks.org/const-member-functions-c/