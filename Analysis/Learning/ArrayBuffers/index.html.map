{"version":3,"sources":["main.cpp","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\ostream","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\iterator","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\ios","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\__locale","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\__string","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\locale","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\streambuf","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\memory","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\string","C:\\emsdk\\emscripten\\1.38.30\\system\\include\\libcxx\\type_traits"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AACA;;;;;;;;;;AC01BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA/IA;AAAA;;;AAndA;AAAA;;AAkeA;AAMA;AAAA;;AAjBA;;;;ACqUA;AAAA;AAAA;AAAA;AAAA;;;;;ACtsBA;AAAA;ADssBA;ADpUA;AACA;AAAA;AAAA;AAAA;AAAA;;;AE7RA;AAAA;AF6RA;AAAA;AACA;AAAA;AAAA;AACA;AAFA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AEgCA;AAAA;AAAA;AAAA;;;;;AARA;;ACtgBA;AAAA;ADsgBA;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;ADuGA;AASA;AAAA;AAAA;;AACA;AAAA;AAAA;AFzCA;AAAA;AAAA;;;ACiVA;AAAA;;ADtUA;AAMA;AAAA;;AATA;AAAA;AAAA;AAAA;AAAA;;;;AE1HA;;;;AAlFA;AAAA;AAAA;AAAA;AAAA;AF+MA;AAMA;AAAA;;;;;;;;AI7gBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACgpCA;AAAA;;AACA;AAoCA;AAAA;;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AHp3BA;AAAA;AGo3BA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;;;;ACjpCA;AAAA;AAAA;AAAA;AAAA;AAAA;ADipCA;AAAA;;AAEA;AACA;AAuBA;AAAA;;;AApBA;AAAA;;AAEA;AAAA;;;;;;;;;AE6rBA;;;;AC3WA;AAAA;AAAA;AHjVA;;;;;;;;;;;AGtJA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAkFA;;;;;;;;;;AD7VA;;AEzhBA;;;;AF+oBA;AF2SA;;;;;AC1pCA;AAAA;AAAA;AAAA;AAAA;AAAA;AD0pCA;AAAA;;AAEA;AACA;;;AAEA;;AAAA;;;;AAYA;AAAA;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;;;;ACnqCA;AAAA;AAAA;AAAA;AAAA;AAAA;ADmqCA;AAAA;;AAEA;AACA;AAKA;AAAA;;;AAFA;;;;AH74BA;AAAA;AAAA;AACA;AAAA;AAAA;AG64BA;AACA;AAAA;;;;;;;;;;ADjqCA;AAAA;AAAA;AAAA;;;;;AAEA","file":"index.html","sourcesContent":["#include <iostream>\r\n\r\nint main()\r\n{\r\n\tstd::cout << \"Hello\";\r\n}","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n    { this->init(__sb); }\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_CXX03_LANG\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n\n    // 27.7.2.3 Assign/swap\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_ostream& __rhs)\n    { basic_ios<char_type, traits_type>::swap(__rhs); }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.2.6 Formatted output:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type tellp();\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(pos_type __pos);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string_view<_CharT, _Traits> __sv)\n{\n    return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\n#ifndef _LIBCPP_HAS_NO_DECLTYPE\ntemplate<class _CharT, class _Traits, class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<void, typename __void_t<decltype(declval<basic_ostream<_CharT, _Traits>&>() << declval<_Yp>())>::type>::value,\n    basic_ostream<_CharT, _Traits>&\n>::type\noperator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p)\n{\n    return __os << __p.get();\n}\n#endif\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// 27.4.3, iterator operations\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>  // constexpr in C++17\n  constexpr void advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>  // constexpr in C++17\n  constexpr typename iterator_traits<InputIterator>::difference_type\n    distance(InputIterator first, InputIterator last);\n\ntemplate <class InputIterator>  // constexpr in C++17\n  constexpr InputIterator next(InputIterator x,\ntypename iterator_traits<InputIterator>::difference_type n = 1);\n\ntemplate <class BidirectionalIterator>  // constexpr in C++17\n  constexpr BidirectionalIterator prev(BidirectionalIterator x,\n    typename iterator_traits<BidirectionalIterator>::difference_type n = 1);    \n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    constexpr reverse_iterator();\n    constexpr explicit reverse_iterator(Iterator x);\n    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);\n    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);\n    constexpr Iterator base() const;\n    constexpr reference operator*() const;\n    constexpr pointer   operator->() const;\n    constexpr reverse_iterator& operator++();\n    constexpr reverse_iterator  operator++(int);\n    constexpr reverse_iterator& operator--();\n    constexpr reverse_iterator  operator--(int);\n    constexpr reverse_iterator  operator+ (difference_type n) const;\n    constexpr reverse_iterator& operator+=(difference_type n);\n    constexpr reverse_iterator  operator- (difference_type n) const;\n    constexpr reverse_iterator& operator-=(difference_type n);\n    constexpr reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)\n-> decltype(__y.base() - __x.base());   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, \n          const reverse_iterator<Iterator>& x);   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef void                        reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef void                         reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef void                   reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class Iterator>\nclass move_iterator {\npublic:\n    typedef Iterator                                              iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type   difference_type;\n    typedef Iterator                                              pointer;\n    typedef typename iterator_traits<Iterator>::value_type        value_type;\n    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;\n    typedef value_type&&                                          reference;\n \n    constexpr move_iterator();  // all the constexprs are in C++17\n    constexpr explicit move_iterator(Iterator i);\n    template <class U>\n      constexpr move_iterator(const move_iterator<U>& u);\n    template <class U>\n      constexpr move_iterator& operator=(const move_iterator<U>& u);\n    constexpr iterator_type base() const;\n    constexpr reference operator*() const;\n    constexpr pointer operator->() const;\n    constexpr move_iterator& operator++();\n    constexpr move_iterator operator++(int);\n    constexpr move_iterator& operator--();\n    constexpr move_iterator operator--(int);\n    constexpr move_iterator operator+(difference_type n) const; \n    constexpr move_iterator& operator+=(difference_type n); \n    constexpr move_iterator operator-(difference_type n) const; \n    constexpr move_iterator& operator-=(difference_type n); \n    constexpr unspecified operator[](difference_type n) const;\nprivate:\n    Iterator current; // exposition only\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto   // constexpr in C++17\noperator-(const move_iterator<Iterator1>& x,\n          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());\n\ntemplate <class Iterator>\nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17\n            typename move_iterator<Iterator>::difference_type n, \n            const move_iterator<Iterator>& x);\n\ntemplate <class Iterator>   // constexpr in C++17\nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);\n\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());\ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);\ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);\n\ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14\ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_cv<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TEMPLATE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename enable_if\n<\n    __is_input_iterator<_InputIter>::value, \n    _InputIter\n>::type\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidirectionalIter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\ntypename enable_if\n<\n    __is_bidirectional_iterator<_BidirectionalIter>::value, \n    _BidirectionalIter\n>::type\nprev(_BidirectionalIter __x,\n     typename iterator_traits<_BidirectionalIter>::difference_type __n = 1)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\n\ntemplate <class _Tp, class = void>\nstruct __is_stashing_iterator : false_type {};\n\ntemplate <class _Tp>\nstruct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>\n  : true_type {};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\n\n    static_assert(!__is_stashing_iterator<_Iter>::value,\n      \"The specified iterator type cannot be used with reverse_iterator; \"\n      \"Using stashing iterators with reverse_iterator causes undefined behavior\");\n\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator() : __t(), current() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)\n            { __t = current = __u.base(); return *this; }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference         operator[](difference_type __n) const {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n-> decltype(__y.base() - __x.base())\n{\n    return __y.base() - __x.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TEMPLATE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,\n               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);\n\n    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,\n               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);\n};\n\ntemplate <class _Tp, class _CharT, class _Traits, class _Distance>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,\n           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)\n{\n    return __x.__in_stream_ == __y.__in_stream_;\n}\n\ntemplate <class _Tp, class _CharT, class _Traits, class _Distance>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,\n           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up>\n      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 \n    reference operator*() const { return static_cast<reference>(*__i); }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n-> decltype(__x.base() - __y.base())\n{\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base());\n#else\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i);\n\n#endif\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Iter1, class _Iter2>\n    friend\n    auto\n    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n    -> decltype(__x.base() - __y.base());\n#else\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n#else\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  typename enable_if\n  <\n      is_trivially_copy_assignable<_Tp>::value,\n      __wrap_iter<_Tp*>\n  >::type\n  __unwrap_iter(__wrap_iter<_Tp*> __i);\n#endif\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base())\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n    \ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))\n{\n    return _VSTD::begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))\n{\n    return _VSTD::end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))\n{\n    return _VSTD::rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))\n{\n    return _VSTD::rend(__c);\n}\n\n#endif\n\n\n#else  // defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n#if _LIBCPP_STD_VER > 14\n\n// #if _LIBCPP_STD_VER > 11\n// template <>\n// struct _LIBCPP_TEMPLATE_VIS plus<void>\n// {\n//     template <class _T1, class _T2>\n//     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n//     auto operator()(_T1&& __t, _T2&& __u) const\n//     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n//     -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n//         { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n//     typedef void is_transparent;\n// };\n// #endif\n\ntemplate <class _Cont>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr auto size(const _Cont& __c)\n_NOEXCEPT_(noexcept(__c.size()))\n-> decltype        (__c.size())\n{ return            __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr auto empty(const _Cont& __c)\n_NOEXCEPT_(noexcept(__c.empty()))\n-> decltype        (__c.empty())\n{ return            __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\n_LIBCPP_NODISCARD_AFTER_CXX17 inline _LIBCPP_INLINE_VISIBILITY\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\ninline _LIBCPP_INLINE_VISIBILITY\nauto data(_Cont& __c)\n_NOEXCEPT_(noexcept(__c.data()))\n-> decltype        (__c.data())\n{ return            __c.data(); }\n\ntemplate <class _Cont> constexpr\ninline _LIBCPP_INLINE_VISIBILITY\nauto data(const _Cont& __c)\n_NOEXCEPT_(noexcept(__c.data()))\n-> decltype        (__c.data()) \n{ return            __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\n#if defined(_LIBCPP_CXX03_LANG)\nstruct _LIBCPP_TYPE_VIS __cxx03_bool {\n  typedef void (__cxx03_bool::*__bool_type)();\n  void __true_value() {}\n};\n#endif\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n  // __true_value will generate undefined references when linking unless\n  // we give it internal linkage.\n\n#if defined(_LIBCPP_CXX03_LANG)\n    _LIBCPP_ALWAYS_INLINE\n    operator __cxx03_bool::__bool_type() const {\n        return !fail() ? &__cxx03_bool::__true_value : nullptr;\n    }\n#else\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT operator bool() const {return !fail();}\n#endif\n\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT_LIKE)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif defined(__sun__)\n# include <xlocale.h>\n# include <support/solaris/xlocale.h>\n#elif defined(_NEWLIB_VERSION)\n# include <support/newlib/xlocale.h>\n#elif (defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#elif defined(__Fuchsia__)\n# include <support/fuchsia/xlocale.h>\n#elif defined(_LIBCPP_HAS_MUSL_LIBC)\n# include <support/musl/xlocale.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if !defined(_LIBCPP_LOCALE__L_EXTENSIONS)\nstruct __libcpp_locale_guard {\n  _LIBCPP_INLINE_VISIBILITY\n  __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~__libcpp_locale_guard() {\n    if (__old_loc_)\n      uselocale(__old_loc_);\n  }\n\n  locale_t __old_loc_;\nprivate:\n  __libcpp_locale_guard(__libcpp_locale_guard const&);\n  __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);\n};\n#elif defined(_LIBCPP_MSVCRT_LIKE)\nstruct __libcpp_locale_guard {\n    __libcpp_locale_guard(locale_t __l) :\n        __status(_configthreadlocale(_ENABLE_PER_THREAD_LOCALE)),\n        __locale_collate(setlocale(LC_COLLATE, __l.__get_locale())),\n        __locale_ctype(setlocale(LC_CTYPE, __l.__get_locale())),\n        __locale_monetary(setlocale(LC_MONETARY, __l.__get_locale())),\n        __locale_numeric(setlocale(LC_NUMERIC, __l.__get_locale())),\n        __locale_time(setlocale(LC_TIME, __l.__get_locale()))\n        // LC_MESSAGES is not supported on Windows.\n    {}\n    ~__libcpp_locale_guard() {\n        setlocale(LC_COLLATE, __locale_collate);\n        setlocale(LC_CTYPE, __locale_ctype);\n        setlocale(LC_MONETARY, __locale_monetary);\n        setlocale(LC_NUMERIC, __locale_numeric);\n        setlocale(LC_TIME, __locale_time);\n        _configthreadlocale(__status);\n    }\n    int __status;\n    char* __locale_collate;\n    char* __locale_ctype;\n    char* __locale_monetary;\n    char* __locale_numeric;\n    char* __locale_time;\n};\n#endif\n\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    _LIBCPP_AVAILABILITY_LOCALE_CATEGORY\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet>\n      _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n      locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n    if (!_VSTD::has_facet<_Facet>(__other))\n        __throw_runtime_error(\"locale::combine: locale missing facet\");\n\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#if defined(__GLIBC__)\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_LIBCPP_MSVCRT_LIKE)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n# ifdef __APPLE__\n    typedef __uint32_t mask;\n# elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n    typedef unsigned short mask;\n# endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#elif defined(_NEWLIB_VERSION)\n    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.\n    typedef char mask;\n    static const mask space  = _S;\n    static const mask print  = _P | _U | _L | _N | _B;\n    static const mask cntrl  = _C;\n    static const mask upper  = _U;\n    static const mask lower  = _L;\n    static const mask alpha  = _U | _L;\n    static const mask digit  = _N;\n    static const mask punct  = _P;\n    static const mask xdigit = _X | _N;\n    static const mask blank  = _B;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT\n#else\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TEMPLATE_VIS codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP___STRING\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <__debug>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#ifdef _LIBCPP_HAS_CATOPEN\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n#include <__bsd_locale_defaults.h>\n#else\n#include <__bsd_locale_fallbacks.h>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__CloudABI__) || defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n\n#else\n    static string __stage2_int_prep(ios_base& __iob, _CharT& __thousands_sep)\n    {\n        locale __loc = __iob.getloc();\n        const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n        __thousands_sep = __np.thousands_sep();\n        return __np.grouping();\n    }\n\n    const _CharT* __do_widen(ios_base& __iob, _CharT* __atoms) const\n    {\n      return __do_widen_p(__iob, __atoms);\n    }\n\n\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms);\nprivate:\n    template<typename T>\n    const T* __do_widen_p(ios_base& __iob, T* __atoms) const\n    {\n      locale __loc = __iob.getloc();\n      use_facet<ctype<T> >(__loc).widen(__src, __src + 26, __atoms);\n      return __atoms;\n    }\n\n    const char* __do_widen_p(ios_base& __iob, char* __atoms) const\n    {\n      (void)__iob;\n      (void)__atoms;\n      return __src;\n    }\n#endif\n};\n\n#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n#endif\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n#else\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, const _CharT* __atoms)\n\n#endif\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\n_Tp __do_strtod(const char* __a, char** __p2);\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nfloat __do_strtod<float>(const char* __a, char** __p2) {\n    return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\ndouble __do_strtod<double>(const char* __a, char** __p2) {\n    return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nlong double __do_strtod<long double>(const char* __a, char** __p2) {\n    return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return __ld;\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __thousands_sep;\n    const int __atoms_size = 26;\n#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n    char_type __atoms1[__atoms_size];\n    const char_type *__atoms = this->__do_widen(__iob, __atoms1);\n    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);\n#else\n    char_type __atoms[__atoms_size];\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n#endif\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __thousands_sep;\n    const int __atoms_size = 26;\n#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n    char_type __atoms1[__atoms_size];\n    const char_type *__atoms = this->__do_widen(__iob, __atoms1);\n    string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);\n#else\n    char_type __atoms[__atoms_size];\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n#endif\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n    if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + ((__iob.flags() & ios_base::showbase) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n\n    _LIBCPP_ALWAYS_INLINE\n    ~__time_get_c_storage() {}\n};\n\ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__weeks() const;\ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__months() const;\ntemplate <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__am_pm() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__c() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__r() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__x() const;\ntemplate <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__X() const;\n\ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__weeks() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__months() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__c() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__r() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__x() const;\ntemplate <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__X() const;\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, false>::init(const char*);\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, true>::init(const char*);\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    if (__new_cap == 0)\n        __new_cap = sizeof(_Tp);\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            _LIBCPP_FALLTHROUGH();\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#else // !_LIBCPP_HAS_CATOPEN\n    return -1;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#else // !_LIBCPP_HAS_CATOPEN\n    return __dflt;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TEMPLATE_VIS wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n\n    if (__wide_err_string_.empty())\n        __throw_range_error(\"wstring_convert: from_bytes error\");\n\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n\n    if (__byte_err_string_.empty())\n        __throw_range_error(\"wstring_convert: to_bytes error\");\n\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TEMPLATE_VIS wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n             _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n             if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            // FIXME: Do we ever need to restore the state here?\n            //state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, \n                               (char_type*) const_cast<char *>(__extbufend_));\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp(const_cast<char_type *>(__e), this->pptr());\n                        this->__pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0, now check __way\n    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)\n        return pos_type(off_type(-1));\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_LOCALE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale pubimbue(const locale& __loc) {\n        imbue(__loc);\n        locale __r = __loc_;\n        __loc_ = __loc;\n        return __r;\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale getloc() const { return __loc_; }\n\n    // 27.6.2.2.2 buffer and positioning:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)\n    { return setbuf(__s, __n); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekoff(__off, __way, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekpos(__sp, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int pubsync() { return sync(); }\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize in_avail() {\n        if (__ninp_ < __einp_)\n            return static_cast<streamsize>(__einp_ - __ninp_);\n        return showmanyc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type snextc() {\n        if (sbumpc() == traits_type::eof())\n            return traits_type::eof();\n        return sgetc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sbumpc() {\n        if (__ninp_ == __einp_)\n            return uflow();\n        return traits_type::to_int_type(*__ninp_++);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sgetc() {\n        if (__ninp_ == __einp_)\n            return underflow();\n        return traits_type::to_int_type(*__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sgetn(char_type* __s, streamsize __n)\n    { return xsgetn(__s, __n); }\n\n    // 27.6.2.2.4 Putback:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputbackc(char_type __c) {\n        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n            return pbackfail(traits_type::to_int_type(__c));\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sungetc() {\n        if (__binp_ == __ninp_)\n          return pbackfail();\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    // 27.6.2.2.5 Put area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputc(char_type __c) {\n        if (__nout_ == __eout_)\n            return overflow(traits_type::to_int_type(__c));\n        *__nout_++ = __c;\n        return traits_type::to_int_type(__c);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sputn(const char_type* __s, streamsize __n)\n    { return xsputn(__s, __n); }\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void gbump(int __n) { __ninp_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {\n        __binp_ = __gbeg;\n        __ninp_ = __gnext;\n        __einp_ = __gend;\n    }\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void pbump(int __n) { __nout_ += __n; }\n\n    _LIBCPP_ALWAYS_INLINE\n    void __pbump(streamsize __n) { __nout_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setp(char_type* __pbeg, char_type* __pend) {\n        __bout_ = __nout_ = __pbeg;\n        __eout_ = __pend;\n    }\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    while(__i < __n)\n    {\n        if (__ninp_ < __einp_)\n        {\n            const streamsize __len = _VSTD::min(static_cast<streamsize>(INT_MAX),\n                                _VSTD::min(__einp_ - __ninp_, __n - __i));\n            traits_type::copy(__s, __ninp_, __len);\n            __s +=  __len;\n            __i +=  __len;\n            this->gbump(__len);\n        }\n        else if ((__c = uflow()) != __eof)\n        {\n            *__s = traits_type::to_char_type(__c);\n            ++__s;\n            ++__i;\n        }\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\ninline constexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class T> constexpr T* to_address(T* p) noexcept; // C++20\ntemplate <class Ptr> auto to_address(const Ptr& p) noexcept; // C++20\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);                          // [[nodiscard]] in C++20\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint); // [[nodiscard]] in C++20\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};      // removed in C++17\n\ntemplate<class X>\nclass auto_ptr                                  // removed in C++17\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;       // removed in C++17\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class E, class T, class Y, class D>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, unique_ptr<Y, D> const& p);\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);          // removed in C++17\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r); // removed in C++17\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;\n};\n\ntemplate <>  // Added in C++14\nstruct owner_less<void>\n{\n    template <class _Tp, class _Up>\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;\n    template <class _Tp, class _Up>\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;\n\n    typedef void is_transparent;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\ntemplate <class T, class Alloc>\n  inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n#include <cassert>\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp, class = void>\nstruct __has_element_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_element_type<_Tp,\n              typename __void_t<typename _Tp::element_type>::type> : true_type {};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class = void>\nstruct __has_difference_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_difference_type<_Tp,\n            typename __void_t<typename _Tp::difference_type>::type> : true_type {};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\ntemplate <class _Tp, class = void>\nstruct __has_pointer_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_pointer_type<_Tp,\n          typename __void_t<typename _Tp::pointer>::type> : true_type {};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_const_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_const_pointer<_Tp,\n            typename __void_t<typename _Tp::const_pointer>::type> : true_type {};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_void_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_void_pointer<_Tp,\n               typename __void_t<typename _Tp::void_pointer>::type> : true_type {};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_const_void_pointer : false_type {};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer<_Tp,\n            typename __void_t<typename _Tp::const_void_pointer>::type> : true_type {};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\n#if _LIBCPP_STD_VER <= 17\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n#else\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__to_raw_pointer(const _Pointer& __p) _NOEXCEPT\n-> decltype(pointer_traits<_Pointer>::to_address(__p))\n{\n    return pointer_traits<_Pointer>::to_address(__p);\n}\n\ntemplate <class _Pointer, class... _None>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__to_raw_pointer(const _Pointer& __p, _None...) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY constexpr\n_Tp*\nto_address(_Tp* __p) _NOEXCEPT\n{\n    static_assert(!is_function_v<_Tp>, \"_Tp is a function type\");\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nto_address(const _Pointer& __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p);\n}\n#endif\n\ntemplate <class _Tp, class = void>\nstruct __has_size_type : false_type {};\n\ntemplate <class _Tp>\nstruct __has_size_type<_Tp,\n               typename __void_t<typename _Tp::size_type>::type> : true_type {};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_copy_assignment : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment<_Tp,\n    typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>\n        : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_move_assignment : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment<_Tp,\n           typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_propagate_on_container_swap : false_type {};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap<_Tp,\n           typename __void_t<typename _Tp::propagate_on_container_swap>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class = void>\nstruct __has_is_always_equal : false_type {};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal<_Tp,\n           typename __void_t<typename _Tp::is_always_equal>::type>\n               : true_type {};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype((void)__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(_VSTD::__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return __allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type&, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return __select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer __allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer __allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a) _NOEXCEPT\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&) _NOEXCEPT\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        __select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        __select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY \n    pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*) const_cast<_Tp *>(__p));}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; }\n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n#endif\n\ntemplate <class _Tp, int _Idx,\n          bool _CanBeEmptyBase =\n              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>\nstruct __compressed_pair_elem {\n  typedef _Tp _ParamT;\n  typedef _Tp& reference;\n  typedef const _Tp& const_reference;\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() : __value_() {}\n\n  template <class _Up, class = typename enable_if<\n      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value\n  >::type>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr explicit\n  __compressed_pair_elem(_Up&& __u)\n      : __value_(_VSTD::forward<_Up>(__u)){};\n\n  template <class... _Args, size_t... _Indexes>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,\n                         __tuple_indices<_Indexes...>)\n      : __value_(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}\n#else\n  _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_() {}\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return __value_; }\n  _LIBCPP_INLINE_VISIBILITY\n  const_reference __get() const _NOEXCEPT { return __value_; }\n\nprivate:\n  _Tp __value_;\n};\n\ntemplate <class _Tp, int _Idx>\nstruct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {\n  typedef _Tp _ParamT;\n  typedef _Tp& reference;\n  typedef const _Tp& const_reference;\n  typedef _Tp __value_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr __compressed_pair_elem() = default;\n\n  template <class _Up, class = typename enable_if<\n        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value\n  >::type>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr explicit\n  __compressed_pair_elem(_Up&& __u)\n      : __value_type(_VSTD::forward<_Up>(__u)){};\n\n  template <class... _Args, size_t... _Indexes>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,\n                         __tuple_indices<_Indexes...>)\n      : __value_type(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) {}\n#else\n  _LIBCPP_INLINE_VISIBILITY __compressed_pair_elem() : __value_type() {}\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair_elem(_ParamT __p)\n      : __value_type(std::forward<_ParamT>(__p)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT { return *this; }\n  _LIBCPP_INLINE_VISIBILITY\n  const_reference __get() const _NOEXCEPT { return *this; }\n};\n\n// Tag used to construct the second element of the compressed pair.\nstruct __second_tag {};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair : private __compressed_pair_elem<_T1, 0>,\n                          private __compressed_pair_elem<_T2, 1> {\n  typedef __compressed_pair_elem<_T1, 0> _Base1;\n  typedef __compressed_pair_elem<_T2, 1> _Base2;\n\n  // NOTE: This static assert should never fire because __compressed_pair\n  // is *almost never* used in a scenario where it's possible for T1 == T2.\n  // (The exception is std::function where it is possible that the function\n  //  object and the allocator have the same type).\n  static_assert((!is_same<_T1, _T2>::value),\n    \"__compressed_pair cannot be instantated when T1 and T2 are the same type; \"\n    \"The current implementation is NOT ABI-compatible with the previous \"\n    \"implementation for this configuration\");\n\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n  template <bool _Dummy = true,\n      class = typename enable_if<\n          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&\n          __dependent_type<is_default_constructible<_T2>, _Dummy>::value\n      >::type\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr __compressed_pair() {}\n\n  template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,\n                                                   __compressed_pair>::value,\n                                          bool>::type = true>\n  _LIBCPP_INLINE_VISIBILITY constexpr explicit\n  __compressed_pair(_Tp&& __t)\n      : _Base1(std::forward<_Tp>(__t)), _Base2() {}\n\n  template <class _Tp>\n  _LIBCPP_INLINE_VISIBILITY constexpr\n  __compressed_pair(__second_tag, _Tp&& __t)\n      : _Base1(), _Base2(std::forward<_Tp>(__t)) {}\n\n  template <class _U1, class _U2>\n  _LIBCPP_INLINE_VISIBILITY constexpr\n  __compressed_pair(_U1&& __t1, _U2&& __t2)\n      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}\n\n  template <class... _Args1, class... _Args2>\n  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                    tuple<_Args2...> __second_args)\n      : _Base1(__pc, _VSTD::move(__first_args),\n               typename __make_tuple_indices<sizeof...(_Args1)>::type()),\n        _Base2(__pc, _VSTD::move(__second_args),\n               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}\n\n#else\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair() {}\n\n  _LIBCPP_INLINE_VISIBILITY explicit\n  __compressed_pair(_T1 __t1) : _Base1(_VSTD::forward<_T1>(__t1)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair(__second_tag, _T2 __t2)\n      : _Base1(), _Base2(_VSTD::forward<_T2>(__t2)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  __compressed_pair(_T1 __t1, _T2 __t2)\n      : _Base1(_VSTD::forward<_T1>(__t1)), _Base2(_VSTD::forward<_T2>(__t2)) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base1::reference first() _NOEXCEPT {\n    return static_cast<_Base1&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base1::const_reference first() const _NOEXCEPT {\n    return static_cast<_Base1 const&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base2::reference second() _NOEXCEPT {\n    return static_cast<_Base2&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename _Base2::const_reference second() const _NOEXCEPT {\n    return static_cast<_Base2 const&>(*this).__get();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(__compressed_pair& __x)\n    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n               __is_nothrow_swappable<_T2>::value)\n  {\n    using std::swap;\n    swap(first(), __x.first());\n    swap(second(), __x.second());\n  }\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n               __is_nothrow_swappable<_T2>::value) {\n  __x.swap(__y);\n}\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete {\n    static_assert(!is_function<_Tp>::value,\n                  \"default_delete cannot be instantiated for function types\");\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;\n#else\n  _LIBCPP_INLINE_VISIBILITY default_delete() {}\n#endif\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  default_delete(const default_delete<_Up>&,\n                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =\n                     0) _NOEXCEPT {}\n\n  _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __ptr) const _NOEXCEPT {\n    static_assert(sizeof(_Tp) > 0,\n                  \"default_delete can not delete incomplete type\");\n    static_assert(!is_void<_Tp>::value,\n                  \"default_delete can not delete incomplete type\");\n    delete __ptr;\n  }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]> {\nprivate:\n  template <class _Up>\n  struct _EnableIfConvertible\n      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};\n\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;\n#else\n  _LIBCPP_INLINE_VISIBILITY default_delete() {}\n#endif\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  default_delete(const default_delete<_Up[]>&,\n                 typename _EnableIfConvertible<_Up>::type* = 0) _NOEXCEPT {}\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  typename _EnableIfConvertible<_Up>::type\n  operator()(_Up* __ptr) const _NOEXCEPT {\n    static_assert(sizeof(_Tp) > 0,\n                  \"default_delete can not delete incomplete type\");\n    static_assert(!is_void<_Tp>::value,\n                  \"default_delete can not delete void type\");\n    delete[] __ptr;\n  }\n};\n\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae {\n  static_assert(!is_reference<_Deleter>::value, \"incorrect specialization\");\n  typedef const _Deleter& __lval_ref_type;\n  typedef _Deleter&& __good_rval_ref_type;\n  typedef true_type __enable_rval_overload;\n};\n\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae<_Deleter const&> {\n  typedef const _Deleter& __lval_ref_type;\n  typedef const _Deleter&& __bad_rval_ref_type;\n  typedef false_type __enable_rval_overload;\n};\n\ntemplate <class _Deleter>\nstruct __unique_ptr_deleter_sfinae<_Deleter&> {\n  typedef _Deleter& __lval_ref_type;\n  typedef _Deleter&& __bad_rval_ref_type;\n  typedef false_type __enable_rval_overload;\n};\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr {\npublic:\n  typedef _Tp element_type;\n  typedef _Dp deleter_type;\n  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\n\n  static_assert(!is_rvalue_reference<deleter_type>::value,\n                \"the specified deleter type cannot be an rvalue reference\");\n\nprivate:\n  __compressed_pair<pointer, deleter_type> __ptr_;\n\n  struct __nat { int __for_bool_; };\n\n#ifndef _LIBCPP_CXX03_LANG\n  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;\n\n  template <bool _Dummy>\n  using _LValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;\n\n  template <bool _Dummy>\n  using _GoodRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;\n\n  template <bool _Dummy>\n  using _BadRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;\n\n  template <bool _Dummy, class _Deleter = typename __dependent_type<\n                             __identity<deleter_type>, _Dummy>::type>\n  using _EnableIfDeleterDefaultConstructible =\n      typename enable_if<is_default_constructible<_Deleter>::value &&\n                         !is_pointer<_Deleter>::value>::type;\n\n  template <class _ArgType>\n  using _EnableIfDeleterConstructible =\n      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;\n\n  template <class _UPtr, class _Up>\n  using _EnableIfMoveConvertible = typename enable_if<\n      is_convertible<typename _UPtr::pointer, pointer>::value &&\n      !is_array<_Up>::value\n  >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterConvertible = typename enable_if<\n      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||\n      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterAssignable = typename enable_if<\n      is_assignable<_Dp&, _UDel&&>::value\n    >::type;\n\npublic:\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, __d) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterConvertible<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(auto_ptr<_Up>&& __p,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value &&\n                                    is_same<_Dp, default_delete<_Tp>>::value,\n                                __nat>::type = __nat()) _NOEXCEPT\n      : __ptr_(__p.release()) {}\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n    return *this;\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterAssignable<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n#else  // _LIBCPP_CXX03_LANG\nprivate:\n  unique_ptr(unique_ptr&);\n  template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep>&);\n\n  unique_ptr& operator=(unique_ptr&);\n  template <class _Up, class _Ep> unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr() : __ptr_(pointer())\n  {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n    static_assert(is_default_constructible<deleter_type>::value,\n                  \"unique_ptr::deleter_type is not default constructible\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t) : __ptr_(pointer())\n  {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p)\n      : __ptr_(_VSTD::move(__p)) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator __rv<unique_ptr>() {\n    return __rv<unique_ptr>(*this);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(__rv<unique_ptr> __u)\n      : __ptr_(__u->release(),\n               _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n  template <class _Up, class _Ep>\n  _LIBCPP_INLINE_VISIBILITY\n  typename enable_if<\n      !is_array<_Up>::value &&\n          is_convertible<typename unique_ptr<_Up, _Ep>::pointer,\n                         pointer>::value &&\n          is_assignable<deleter_type&, _Ep&>::value,\n      unique_ptr&>::type\n  operator=(unique_ptr<_Up, _Ep> __u) {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, deleter_type __d)\n      : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n#endif // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n      typename enable_if<is_convertible<_Up*, _Tp*>::value &&\n                             is_same<_Dp, default_delete<_Tp> >::value,\n                         unique_ptr&>::type\n      operator=(auto_ptr<_Up> __p) {\n    reset(__p.release());\n    return *this;\n  }\n#endif\n\n  _LIBCPP_INLINE_VISIBILITY\n  ~unique_ptr() { reset(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(nullptr_t) _NOEXCEPT {\n    reset();\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename add_lvalue_reference<_Tp>::type\n  operator*() const {\n    return *__ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer operator->() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer get() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  deleter_type& get_deleter() _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  const deleter_type& get_deleter() const _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n    return __ptr_.first() != nullptr;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer release() _NOEXCEPT {\n    pointer __t = __ptr_.first();\n    __ptr_.first() = pointer();\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void reset(pointer __p = pointer()) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(unique_ptr& __u) _NOEXCEPT {\n    __ptr_.swap(__u.__ptr_);\n  }\n};\n\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp> {\npublic:\n  typedef _Tp element_type;\n  typedef _Dp deleter_type;\n  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\n\nprivate:\n  __compressed_pair<pointer, deleter_type> __ptr_;\n\n  template <class _From>\n  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};\n\n  template <class _FromElem>\n  struct _CheckArrayPointerConversion<_FromElem*>\n      : integral_constant<bool,\n          is_same<_FromElem*, pointer>::value ||\n            (is_same<pointer, element_type*>::value &&\n             is_convertible<_FromElem(*)[], element_type(*)[]>::value)\n      >\n  {};\n\n#ifndef _LIBCPP_CXX03_LANG\n  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;\n\n  template <bool _Dummy>\n  using _LValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;\n\n  template <bool _Dummy>\n  using _GoodRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;\n\n  template <bool _Dummy>\n  using _BadRValRefType =\n      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;\n\n  template <bool _Dummy, class _Deleter = typename __dependent_type<\n                             __identity<deleter_type>, _Dummy>::type>\n  using _EnableIfDeleterDefaultConstructible =\n      typename enable_if<is_default_constructible<_Deleter>::value &&\n                         !is_pointer<_Deleter>::value>::type;\n\n  template <class _ArgType>\n  using _EnableIfDeleterConstructible =\n      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;\n\n  template <class _Pp>\n  using _EnableIfPointerConvertible = typename enable_if<\n      _CheckArrayPointerConversion<_Pp>::value\n  >::type;\n\n  template <class _UPtr, class _Up,\n        class _ElemT = typename _UPtr::element_type>\n  using _EnableIfMoveConvertible = typename enable_if<\n      is_array<_Up>::value &&\n      is_same<pointer, element_type*>::value &&\n      is_same<typename _UPtr::pointer, _ElemT*>::value &&\n      is_convertible<_ElemT(*)[], element_type(*)[]>::value\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterConvertible = typename enable_if<\n      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||\n      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)\n    >::type;\n\n  template <class _UDel>\n  using _EnableIfDeleterAssignable = typename enable_if<\n      is_assignable<_Dp&, _UDel&&>::value\n    >::type;\n\npublic:\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>>\n  _LIBCPP_INLINE_VISIBILITY\n  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterDefaultConstructible<_Dummy>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(_Pp __p) noexcept\n      : __ptr_(__p) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, __d) {}\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept\n      : __ptr_(nullptr, __d) {}\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(__p, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept\n      : __ptr_(nullptr, _VSTD::move(__d)) {\n    static_assert(!is_reference<deleter_type>::value,\n                  \"rvalue deleter bound to reference\");\n  }\n\n  template <class _Pp, bool _Dummy = true,\n            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,\n            class = _EnableIfPointerConvertible<_Pp>>\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(unique_ptr&& __u) noexcept {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n    return *this;\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterConvertible<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept\n      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {\n  }\n\n  template <class _Up, class _Ep,\n      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,\n      class = _EnableIfDeleterAssignable<_Ep>\n  >\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr&\n  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {\n    reset(__u.release());\n    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n    return *this;\n  }\n\n#else // _LIBCPP_CXX03_LANG\nprivate:\n  template <class _Up> explicit unique_ptr(_Up);\n\n  unique_ptr(unique_ptr&);\n  template <class _Up> unique_ptr(unique_ptr<_Up>&);\n\n  unique_ptr& operator=(unique_ptr&);\n  template <class _Up> unique_ptr& operator=(unique_ptr<_Up>&);\n\n  template <class _Up>\n  unique_ptr(_Up __u,\n             typename conditional<\n                 is_reference<deleter_type>::value, deleter_type,\n                 typename add_lvalue_reference<const deleter_type>::type>::type,\n             typename enable_if<is_convertible<_Up, pointer>::value,\n                                __nat>::type = __nat());\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr() : __ptr_(pointer()) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t) : __ptr_(pointer()) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  explicit unique_ptr(pointer __p) : __ptr_(__p) {\n    static_assert(!is_pointer<deleter_type>::value,\n                  \"unique_ptr constructed with null function pointer deleter\");\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(pointer __p, deleter_type __d)\n      : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(nullptr_t, deleter_type __d)\n      : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  operator __rv<unique_ptr>() {\n    return __rv<unique_ptr>(*this);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr(__rv<unique_ptr> __u)\n      : __ptr_(__u->release(),\n               _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(__rv<unique_ptr> __u) {\n    reset(__u->release());\n    __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n    return *this;\n  }\n\n#endif // _LIBCPP_CXX03_LANG\n\npublic:\n  _LIBCPP_INLINE_VISIBILITY\n  ~unique_ptr() { reset(); }\n\n  _LIBCPP_INLINE_VISIBILITY\n  unique_ptr& operator=(nullptr_t) _NOEXCEPT {\n    reset();\n    return *this;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  typename add_lvalue_reference<_Tp>::type\n  operator[](size_t __i) const {\n    return __ptr_.first()[__i];\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  pointer get() const _NOEXCEPT {\n    return __ptr_.first();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  deleter_type& get_deleter() _NOEXCEPT {\n    return __ptr_.second();\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  const deleter_type& get_deleter() const _NOEXCEPT {\n    return __ptr_.second();\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {\n    return __ptr_.first() != nullptr;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  pointer release() _NOEXCEPT {\n    pointer __t = __ptr_.first();\n    __ptr_.first() = pointer();\n    return __t;\n  }\n\n  template <class _Pp>\n  _LIBCPP_INLINE_VISIBILITY\n  typename enable_if<\n      _CheckArrayPointerConversion<_Pp>::value\n  >::type\n  reset(_Pp __p) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = __p;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void reset(nullptr_t = nullptr) _NOEXCEPT {\n    pointer __tmp = __ptr_.first();\n    __ptr_.first() = nullptr;\n    if (__tmp)\n      __ptr_.second()(__tmp);\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  void swap(unique_ptr& __u) _NOEXCEPT {\n    __ptr_.swap(__u.__ptr_);\n  }\n\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, class _Dp>\n#ifdef _LIBCPP_CXX03_LANG\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n#else\nstruct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<\n    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>\n#endif\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t __size_;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++__size_;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : __size_(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\n// NOTE: Relaxed and acq/rel atomics (for increment and decrement respectively)\n// should be sufficient for thread safety.\n// See https://bugs.llvm.org/show_bug.cgi?id=22803\n#if defined(__clang__) && __has_builtin(__atomic_add_fetch)          \\\n                       && defined(__ATOMIC_RELAXED)                  \\\n                       && defined(__ATOMIC_ACQ_REL)\n#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT\n#elif !defined(__clang__) && defined(_GNUC_VER) && _GNUC_VER >= 407\n#   define _LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _Tp\n__libcpp_atomic_refcount_increment(_Tp& __t) _NOEXCEPT\n{\n#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)\n    return __atomic_add_fetch(&__t, 1, __ATOMIC_RELAXED);\n#else\n    return __t += 1;\n#endif\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _Tp\n__libcpp_atomic_refcount_decrement(_Tp& __t) _NOEXCEPT\n{\n#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)\n    return __atomic_add_fetch(&__t, -1, __ATOMIC_ACQ_REL);\n#else\n    return __t -= 1;\n#endif\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n#if defined(_LIBCPP_BUILDING_MEMORY) && \\\n    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_shared() _NOEXCEPT {\n      __libcpp_atomic_refcount_increment(__shared_owners_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    bool __release_shared() _NOEXCEPT {\n      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {\n        __on_zero_shared();\n        return true;\n      }\n      return false;\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n#if defined(_LIBCPP_BUILDING_MEMORY) && \\\n    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_shared() _NOEXCEPT {\n      __shared_count::__add_shared();\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    void __add_weak() _NOEXCEPT {\n      __libcpp_atomic_refcount_increment(__shared_weak_owners_);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    void __release_shared() _NOEXCEPT {\n      if (__shared_count::__release_shared())\n        __release_weak();\n    }\n#endif\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : nullptr;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\nstruct __shared_ptr_dummy_rebind_allocator_type;\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<__shared_ptr_dummy_rebind_allocator_type>\n{\npublic:\n    template <class _Other>\n    struct rebind\n    {\n        typedef allocator<_Other> other;\n    };\n};\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#endif\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const _NOEXCEPT\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const _NOEXCEPT\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return static_cast<_Dp*>(__cntrl_\n                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))\n                      : nullptr);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    template <class _Yp, bool = is_function<_Yp>::value>\n        struct __shared_ptr_default_allocator\n        {\n            typedef allocator<_Yp> type;\n        };\n\n    template <class _Yp>\n        struct __shared_ptr_default_allocator<_Yp, true>\n        {\n            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;\n        };\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if<is_convertible<_OrigPtr*,\n                                          const enable_shared_from_this<_Yp>*\n        >::value,\n            void>::type\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     _AllocT > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    static_assert( is_constructible<_Tp, _Args...>::value, \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    static_assert( is_constructible<_Tp, _Args...>::value, \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    static_assert((is_constructible<_Tp>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    static_assert((is_constructible<_Tp, _A0>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1, _A2>::value), \"Can't construct object in make_shared\" );\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    static_assert((is_constructible<_Tp>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    static_assert((is_constructible<_Tp, _A0>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    static_assert((is_constructible<_Tp, _A0, _A1, _A2>::value), \"Can't construct object in allocate_shared\" );\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,\n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n#endif\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,\n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const _NOEXCEPT\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const _NOEXCEPT\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const _NOEXCEPT\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\n__sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2,\n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool,\n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n\n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n\n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n\n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool starts_with(basic_string_view<charT, traits> sv) const noexcept; // C++2a\n    bool starts_with(charT c) const noexcept;                             // C++2a\n    bool starts_with(const charT* s) const;                               // C++2a\n    bool ends_with(basic_string_view<charT, traits> sv) const noexcept;   // C++2a\n    bool ends_with(charT c) const noexcept;                               // C++2a\n    bool ends_with(const charT* s) const;                                 // C++2a\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_PUSH_MACROS\n#include <__undef_macros>\n\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n    ( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef _CharT                                       value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, typename traits_type::char_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#ifdef _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x01;\n    static const size_type __long_mask  = 0x1ul;\n#else  // _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x80;\n    static const size_type __long_mask  = ~(size_type(~0) >> 1);\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#ifdef _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x80;\n    static const size_type __long_mask  = ~(size_type(~0) >> 1);\n#else  // _LIBCPP_BIG_ENDIAN\n    static const size_type __short_mask = 0x01;\n    static const size_type __long_mask  = 0x1ul;\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY basic_string(const _CharT* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, const _Allocator& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, _CharT __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, _CharT __c, const _Allocator& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const _Allocator& __a = _Allocator());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const _Allocator& __a = _Allocator());\n    template<class _Tp>\n        _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n        basic_string(const _Tp& __t, size_type __pos, size_type __n,\n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const _Allocator& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<_CharT> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);\n#endif  // _LIBCPP_CXX03_LANG\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n     _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type __res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(__str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS\n    typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_CXX03_LANG\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14 || defined(_LIBCPP_BUILDING_LIBRARY)\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n#if _LIBCPP_STD_VER > 17\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(__self_view __sv) const _NOEXCEPT\n    { return __self_view(data(), size()).starts_with(__sv); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(front(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool starts_with(const value_type* __s) const _NOEXCEPT\n    { return starts_with(__self_view(__s)); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(__self_view __sv) const _NOEXCEPT\n    { return __self_view(data(), size()).ends_with( __sv); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(value_type __c) const _NOEXCEPT\n    { return !empty() && _Traits::eq(back(), __c); }\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool ends_with(const value_type* __s) const _NOEXCEPT\n    { return ends_with(__self_view(__s)); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   ifdef _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline\n    void __init(const value_type* __s, size_type __sz);\n    inline\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() == __str.__alloc())\n                __alloc() = __str.__alloc();\n            else\n            {\n                if (!__str.__is_long())\n                {\n                    clear();\n                    shrink_to_fit();\n                    __alloc() = __str.__alloc();\n                }\n                else\n                {\n                    allocator_type __a = __str.__alloc();\n                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());\n                    clear();\n                    shrink_to_fit();\n                    __alloc() = _VSTD::move(__a);\n                    __set_long_pointer(__p);\n                    __set_long_cap(__str.__get_long_cap());\n                    __set_long_size(__str.size());\n                }\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__second_tag(), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__second_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    const basic_string& __str, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,\n                                                        size_type __pos, size_type __n,\n                                                        const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n             typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__second_tag(), __a)\n{\n    __self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    initializer_list<_CharT> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n    initializer_list<_CharT> __il, const _Allocator& __a)\n    : __r_(__second_tag(), __a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n// __sz += __n2 - __n1; in this and the below function below can cause unsigned integer overflow,\n// but this is a safe operation, so we disable the check.\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#ifdef _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n    int\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n_LIBCPP_POP_MACROS\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n    template <class T> struct is_aggregate; // C++17\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    template<class T> struct has_unique_object_representations;         // C++17\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class Fn, class... ArgTypes> struct is_invocable;\n    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;\n\n    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;\n    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n    template <class T> struct remove_cvref; // C++20\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class T>\n      using result_of_t       = typename result_of<T>::type;  // C++14\n    template <class Fn, class... ArgTypes>\n      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> inline constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> inline constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> inline constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> inline constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> inline constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> inline constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> inline constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> inline constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> inline constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> inline constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> inline constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> inline constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> inline constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> inline constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> inline constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> inline constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> inline constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> inline constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> inline constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> inline constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> inline constexpr bool is_aggregate_v\n        = is_aggregate<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> inline constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> inline constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> inline constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> inline constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> inline constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> inline constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> inline constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> inline constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> inline constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> inline constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> inline constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> inline constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> inline constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> inline constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> inline constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> inline constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> inline constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> inline constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> inline constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> inline constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> inline constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> inline constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> inline constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> inline constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> inline constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> inline constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n      template<class T> inline constexpr bool has_unique_object_representations_v // C++17\n        = has_unique_object_representations<T>::value;\n\n      // See C++14 20.10.5, type property queries\n      template <class T> inline constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> inline constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> inline constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> inline constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> inline constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> inline constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v\n        = is_invocable<Fn, ArgTypes...>::value;                          // C++17\n      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v\n        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17\n      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v\n        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17\n      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v\n        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        inline constexpr bool negation_v = negation<B>::value;           // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\n#if _LIBCPP_STD_VER > 17\n// aligned_union - same as __uncvref\ntemplate <class _Tp>\nstruct remove_cvref {\n    using type = remove_cv_t<remove_reference_t<_Tp>>;\n};\n\ntemplate <class _Tp> using remove_cvref_t = typename remove_cvref<_Tp>::type;\n#endif\n\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Up, bool>\nstruct __decay {\n    typedef typename remove_cv<_Up>::type type;\n};\n\ntemplate <class _Up>\nstruct __decay<_Up, true> {\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_aggregate\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};\n\n#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_aggregate_v\n    = is_aggregate<_Tp>::value;\n#endif\n\n#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// has_unique_object_representations\n\n#if _LIBCPP_STD_VER > 14 && defined(_LIBCPP_HAS_UNIQUE_OBJECT_REPRESENTATIONS)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_unique_object_representations\n    : public integral_constant<bool, \n       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};\n\n#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool has_unique_object_representations_v\n    = has_unique_object_representations<_Tp>::value;\n#endif\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS common_type<void, void, void>\n{\npublic:\n    typedef void type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename common_type<_Tp, _Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n    : public common_type<_Tp, _Tp> {};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>(), _VSTD::declval<_A2>()), true_type()))\n__is_constructible3_test(_Tp&, _A0&, _A1&, _A2&);\n\ntemplate <class _A0, class _A1, class _A2>\nfalse_type\n__is_constructible3_test(__any, _A0&, _A1&, _A2&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible3_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>(), declval<_A2>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<true, _Tp, _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_void_check\n    : public __is_constructible3_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1, _A2>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1, class _A2>\nstruct __is_constructible3_void_check<true, _Tp, _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat,\n                     class _A2 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible3_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value\n                                        || is_void<_A2>::value,\n                                           _Tp, _A0, _A1, _A2>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, _A1, __is_construct::__nat>\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<false, _Ap[_Np], _A0, _A1, _A2>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1, class _A2>\nstruct __is_constructible3_imp<false, _Ap[], _A0, _A1, _A2>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    using type =\n        typename conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type;\n    static const bool value = type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nusing __nothrow_invokable =\n    __nothrow_invokable_r_imp<\n            __invokable<_Fp, _Args...>::value,\n            true, void, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// invoke_result\n\ntemplate <class _Fn, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS invoke_result\n    : __invoke_of<_Fn, _Args...>\n{\n};\n\ntemplate <class _Fn, class... _Args>\nusing invoke_result_t = typename invoke_result<_Fn, _Args...>::type;\n\n// is_invocable\n\ntemplate <class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_invocable\n    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};\n\ntemplate <class _Ret, class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_invocable_r\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_invocable_v\n    = is_invocable<_Fn, _Args...>::value;\n\ntemplate <class _Ret, class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_invocable_r_v\n    = is_invocable_r<_Ret, _Fn, _Args...>::value;\n\n// is_nothrow_invocable\n\ntemplate <class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable\n    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};\n\ntemplate <class _Ret, class _Fn, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_invocable_r\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_v\n    = is_nothrow_invocable<_Fn, _Args...>::value;\n\ntemplate <class _Ret, class _Fn, class ..._Args>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_invocable_r_v\n    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR constexpr bool is_swappable_with_v\n    = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_swappable_v\n    = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_with_v\n    = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool is_nothrow_swappable_v\n    = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\ntemplate<typename _Fp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_floating_point<_Fp>::value, long long>::type\n __convert_to_integral(_Fp __val) { return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args>\n_LIBCPP_INLINE_VAR constexpr bool conjunction_v\n    = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args>\n_LIBCPP_INLINE_VAR constexpr bool disjunction_v\n    = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp>\n_LIBCPP_INLINE_VAR constexpr bool negation_v\n    = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 14\n// std::byte\nnamespace std  // purposefully not versioned\n{\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &\n  operator<<=(byte& __lhs, _Integer __shift) noexcept\n  { return __lhs = __lhs << __shift; }\n  \ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type\n  operator<< (byte  __lhs, _Integer __shift) noexcept\n  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &\n  operator>>=(byte& __lhs, _Integer __shift) noexcept\n  { return __lhs = __lhs >> __shift; }\n\ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, byte>::type\n  operator>> (byte  __lhs, _Integer __shift) noexcept\n  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }\n  \ntemplate <class _Integer>\n  constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type\n  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }\n\n}\n#endif\n\n#endif  // _LIBCPP_TYPE_TRAITS\n"]}